'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _hoistNonReactStatics = require('hoist-non-react-statics');

var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

if (typeof window !== 'undefined') {
  // Polyfills for intersection-observer
  require('intersection-observer');
}

var isStateless = function isStateless(Component) {
  return !Component.prototype.render;
};

function handleViewport(Component, options) {
  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { disconnectOnLeave: false };

  var InViewport = function (_PureComponent) {
    _inherits(InViewport, _PureComponent);

    function InViewport(props) {
      _classCallCheck(this, InViewport);

      var _this = _possibleConstructorReturn(this, (InViewport.__proto__ || Object.getPrototypeOf(InViewport)).call(this, props));

      _this.observer = null;
      _this.node = null;
      _this.state = {
        inViewport: false
      };
      _this.intersected = false;
      _this.handleIntersection = _this.handleIntersection.bind(_this);
      _this.initIntersectionObserver = _this.initIntersectionObserver.bind(_this);
      _this.setRef = _this.setRef.bind(_this);
      _this.setInnerRef = _this.setInnerRef.bind(_this);
      return _this;
    }

    _createClass(InViewport, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
        this.initIntersectionObserver();
        this.startObserver(this.node, this.observer);
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate(prevProps, prevState) {
        // reset observer on update, to fix race condition that when observer init,
        // the element is not in viewport, such as in animation
        if (!this.intersected && !prevState.inViewport) {
          if (this.observer && this.node) {
            this.observer.unobserve(this.node);
            this.observer.observe(this.node);
          }
        }
      }
    }, {
      key: 'initIntersectionObserver',
      value: function initIntersectionObserver() {
        if (!this.observer) {
          this.observer = new IntersectionObserver(this.handleIntersection, options);
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        this.stopObserver(this.node, this.observer);
      }
    }, {
      key: 'startObserver',
      value: function startObserver(node, observer) {
        if (node && observer) {
          observer.observe(node);
        }
      }
    }, {
      key: 'stopObserver',
      value: function stopObserver(node, observer) {
        if (node && observer) {
          observer.unobserve(node);
          observer.disconnect();
          this.observer = null;
        }
      }
    }, {
      key: 'handleIntersection',
      value: function handleIntersection(entries) {
        var _props = this.props,
            onEnterViewport = _props.onEnterViewport,
            onLeaveViewport = _props.onLeaveViewport;

        var entry = entries[0] || {};
        var isIntersecting = entry.isIntersecting,
            intersectionRatio = entry.intersectionRatio;

        var inViewport = typeof isIntersecting !== 'undefined' ? isIntersecting : intersectionRatio > 0;

        // enter
        if (!this.intersected && inViewport) {
          this.intersected = true;
          onEnterViewport && onEnterViewport();
          this.setState({
            inViewport: inViewport
          });
          return;
        }

        // leave
        if (this.intersected && !inViewport) {
          this.intersected = false;
          onLeaveViewport && onLeaveViewport();
          if (config.disconnectOnLeave) {
            // disconnect obsever on leave
            this.observer && this.observer.disconnect();
          }
          this.setState({
            inViewport: inViewport
          });
        }
      }
    }, {
      key: 'setRef',
      value: function setRef(node) {
        this.node = _reactDom2.default.findDOMNode(node);
      }
    }, {
      key: 'setInnerRef',
      value: function setInnerRef(node) {
        if (node && !this.node) {
          // handle stateless
          this.node = _reactDom2.default.findDOMNode(node);
          this.initIntersectionObserver();
          this.startObserver(this.node, this.observer);
        }
      }
    }, {
      key: 'render',
      value: function render() {
        var _props2 = this.props,
            onEnterViewport = _props2.onEnterViewport,
            onLeaveViewport = _props2.onLeaveViewport,
            others = _objectWithoutProperties(_props2, ['onEnterViewport', 'onLeaveViewport']);
        // pass ref to class and innerRef for stateless component

        var refProps = isStateless(Component) ? { innerRef: this.setInnerRef } : { ref: this.setRef };
        return _react2.default.createElement(Component, Object.assign({}, others, {
          inViewport: this.state.inViewport
        }, refProps));
      }
    }]);

    return InViewport;
  }(_react.PureComponent);

  return (0, _hoistNonReactStatics2.default)(InViewport, Component);
}

exports.default = handleViewport;
module.exports = exports['default'];